/*
 * Copyright COCKTAIL (www.cocktail.org), 1995, 2010 This software
 * is governed by the CeCILL license under French law and abiding by the
 * rules of distribution of free software. You can use, modify and/or
 * redistribute the software under the terms of the CeCILL license as
 * circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * As a counterpart to the access to the source code and rights to copy, modify
 * and redistribute granted by the license, users are provided only with a
 * limited warranty and the software's author, the holder of the economic
 * rights, and the successive licensors have only limited liability. In this
 * respect, the user's attention is drawn to the risks associated with loading,
 * using, modifying and/or developing or reproducing the software by the user
 * in light of its specific status of free software, that may mean that it
 * is complicated to manipulate, and that also therefore means that it is
 * reserved for developers and experienced professionals having in-depth
 * computer knowledge. Users are therefore encouraged to load and test the
 * software's suitability as regards their requirements in conditions enabling
 * the security of their systems and/or data to be ensured and, more generally,
 * to use and operate it in the same conditions as regards security. The
 * fact that you are presently reading this means that you have had knowledge
 * of the CeCILL license and that you accept its terms.
 */
package fr.univlr.cri.planning;

// Generated by the WOLips TemplateEngine Plug-in at 13 avr. 2006 11:10:48

import java.util.TimeZone;
import java.util.Timer;

import org.cocktail.fwkcktlwebapp.common.CktlLog;
import org.cocktail.fwkcktlwebapp.common.util.DateCtrl;
import org.cocktail.fwkcktlwebapp.common.util.StringCtrl;
import org.cocktail.fwkcktlwebapp.server.CktlWebApplication;
import org.cocktail.fwkcktlwebapp.server.version.A_CktlVersion;

import com.webobjects.appserver._private.WOResourceRequestHandler;
import com.webobjects.foundation.NSTimeZone;
import com.webobjects.foundation.NSTimestamp;
import com.webobjects.foundation.NSTimestampFormatter;

import er.extensions.appserver.ERXApplication;
import fr.univlr.cri.planning.constant.LocalSPConstantes;
import fr.univlr.cri.planning.datacenter.ICalendarBus;
import fr.univlr.cri.planning.icalendar.SPCalendar;
import fr.univlr.cri.planning.thread.SPHTTPConnection;
import fr.univlr.cri.planning.timer.TimerCheckRemoteApplications;

//import com.webobjects.appserver.WOWebServiceRegistrar;

public class Application extends CktlWebApplication {

	private TimerCheckRemoteApplications _timerVerifA; // objet qui execute une
																											// methode &
	// intervalle regulier

	private Timer _timer; // gestion du temps

	// nom des cle pour l'acces aux valeur de System.getProperties()
	private final static String SYSTEM_KEY_HTTP_PROXY_HOST = "http.proxyHost";
	private final static String SYSTEM_KEY_HTTP_PROXY_PORT = "http.proxyPort";
	private final static String SYSTEM_KEY_HTTP_PROXY_NO_PROXY_HOST = "http.nonProxyHosts";

	//
	// private final static String SYSTEM_KEY_DEFAULT_TIME_ZONE =
	// "DEFAULT_TIME_ZONE";

	// 0: cal, 1: endTime

	public static void main(String argv[]) {
		// WOApplication.main(argv, Application.class);
		ERXApplication.main(argv, Application.class);
	}

	public Application() {
		super();
		registerRequestHandler(new WOResourceRequestHandler(), resourceRequestHandlerKey());
		setDefaultRequestHandler(requestHandlerForKey(directActionRequestHandlerKey()));
	}

	/**
	 * Initialise le TimeZone a utiliser pour l'application.
	 */
	private void initTimeZones() {
		// appLog().trace(new NSArray(TimeZone.getAvailableIDs()));
		CktlLog.log("Initialisation du NSTimeZone");
		CktlLog.log("NSTimeZone par defaut recupere sur le systeme (avant initialisation) " + NSTimeZone.defaultTimeZone());
		String tz = (String) config().valueForKey("APP_TIME_ZONE");

		// config().stringForKey("DEFAULT_TIME_ZONE")
		if (StringCtrl.isEmpty(tz)) {
			CktlLog.log("Le parametre APP_TIME_ZONE n'est pas defini dans le fichier .config.");
			TimeZone.setDefault(TimeZone.getTimeZone("Europe/Paris"));
			NSTimeZone.setDefaultTimeZone(NSTimeZone.timeZoneWithName("Europe/Paris", false));
		} else {
			NSTimeZone ntz = NSTimeZone.timeZoneWithName(tz, false);
			if (ntz == null) {
				CktlLog.log("Le parametre APP_TIME_ZONE defini dans le fichier .config n'est pas valide (" + tz + ")");
				TimeZone.setDefault(TimeZone.getTimeZone("Europe/Paris"));
				NSTimeZone.setDefaultTimeZone(NSTimeZone.timeZoneWithName("Europe/Paris", false));
			} else {
				TimeZone.setDefault(ntz);
				NSTimeZone.setDefaultTimeZone(ntz);
			}
		}
		CktlLog.log("NSTimeZone par defaut utilise dans l'application " + NSTimeZone.defaultTimeZone());
		NSTimestampFormatter ntf = new NSTimestampFormatter();
		CktlLog.log("Les NSTimestampFormatter analyseront les dates avec le NSTimeZone " + ntf.defaultParseTimeZone());
		CktlLog.log("Les NSTimestampFormatter afficheront les dates avec le NSTimeZone " + ntf.defaultFormatTimeZone());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see fr.univlr.cri.webapp.CRIBasicWebApplication#startRunning()
	 */
	public void startRunning() {
		// settage du timezone
		initTimeZones();
		/*
		 * String tzs = config().stringForKey(SYSTEM_KEY_DEFAULT_TIME_ZONE); if(tzs
		 * == null) { tzs = "CEST"; } java.util.TimeZone tz =
		 * java.util.TimeZone.getTimeZone(tzs); java.util.TimeZone.setDefault(tz);
		 * NSTimeZone.setDefault(tz);
		 */

		rawLogAppInfos();
		rawLogVersionInfos();
		rawLogModelInfos();
		checkModel();

		// gestion timer
		_timerVerifA = new TimerCheckRemoteApplications();
		_timer = new Timer();
		_timer.schedule(_timerVerifA, 10, config().intForKey(KEY_HEARTBEAT_SEND_DELAY) * 1000);

		// initialisations des classes
		SPCalendar.initStaticFields(version());
		SPHTTPConnection.initStaticFields(maxRemoteAppResponseTime(),
				System.getProperty(SYSTEM_KEY_HTTP_PROXY_HOST),
				System.getProperty(SYSTEM_KEY_HTTP_PROXY_PORT),
				System.getProperty(SYSTEM_KEY_HTTP_PROXY_NO_PROXY_HOST));

		// CREATION DU WEBSERVICE
		// WOWebServiceRegistrar.registerWebService("wsplanning", ServPlan.class,
		// new String[] {"serveurPlan"}, true);

		// nettoyage des fichiers de cache
		ICalendarBus.clearCache();

	}

	public String mainModelName() {
		return "SPModel";
	}

	// getters des constantes de l'application

	private Integer _ttlPlanningRead, _ttlICalendarRead, _ttlICalendarWrite,
			_maxRemoteAppResponseTime, _icalendarWeeksBefore, _icalendarWeeksAfter;
	private String _icsSuffixPattern;
	private NSTimestamp _icsDateDebut, _icsDateFin;

	public int ttlPlanningRead() {
		if (_ttlPlanningRead == null)
			_ttlPlanningRead = new Integer(config().intForKey(KEY_TTL_PLANNING_READ) * 1000);
		return _ttlPlanningRead.intValue();
	}

	public int ttlICalendarRead() {
		if (_ttlICalendarRead == null)
			_ttlICalendarRead = new Integer(config().intForKey(KEY_TTL_ICALENDAR_READ) * 1000);
		return _ttlICalendarRead.intValue();
	}

	public int ttlICalendarWrite() {
		if (_ttlICalendarWrite == null)
			_ttlICalendarWrite = new Integer(config().intForKey(KEY_TTL_ICALENDAR_WRITE) * 1000);
		return _ttlICalendarWrite.intValue();
	}

	public int maxRemoteAppResponseTime() {
		if (_maxRemoteAppResponseTime == null)
			_maxRemoteAppResponseTime = new Integer(config().intForKey(KEY_MAX_REMOTE_APP_RESPONSE_TIME) * 1000);
		return _maxRemoteAppResponseTime.intValue();
	}

	private int icalendarWeeksBefore() {
		if (_icalendarWeeksBefore == null)
			_icalendarWeeksBefore = new Integer(config().intForKey(KEY_ICALENDAR_WEEKS_BEFORE));
		return _icalendarWeeksBefore.intValue();
	}

	private int icalendarWeeksAfter() {
		if (_icalendarWeeksAfter == null)
			_icalendarWeeksAfter = new Integer(config().intForKey(KEY_ICALENDAR_WEEKS_AFTER));
		return _icalendarWeeksAfter.intValue();
	}

	public String icsSuffixPattern() {
		if (_icsSuffixPattern == null) {
			_icsSuffixPattern = config().stringForKey(KEY_ICS_SUFFIX_PATTERN);
			// valeur par d√©faut
			if (_icsSuffixPattern == null) {
				_icsSuffixPattern = LocalSPConstantes.ICS_SUFFIX_PATTERN_DEFAULT_VALUE;
			}
		}
		return _icsSuffixPattern;
	}

	public NSTimestamp icsDateDebut() {
		if (_icsDateDebut == null) {
			int wBefore = icalendarWeeksBefore();
			_icsDateDebut = DateCtrl.now().timestampByAddingGregorianUnits(0, 0, -wBefore * 7, 0, 0, 0);
		}
		return _icsDateDebut;
	}

	public NSTimestamp icsDateFin() {
		if (_icsDateFin == null) {
			int wAfter = icalendarWeeksAfter();
			_icsDateFin = DateCtrl.now().timestampByAddingGregorianUnits(0, 0, wAfter * 7, 0, 0, 0);
		}
		return _icsDateFin;
	}

	public String configTableName() {
		return "FwkCktlWebApp_GrhumParametres";
	}

	public String imageLigneSrc() {
		return getImageDefaultURL("ligneApplisDegradee.gif");
	}

	public String imageClefsSrc() {
		return getImageDefaultURL("clefs.gif");
	}

	// ** controle de version **

	// 1 seule instance
	private A_CktlVersion _appCktlVersion;

	// controle de versions
	public A_CktlVersion appCktlVersion() {
		if (_appCktlVersion == null) {
			_appCktlVersion = new fr.univlr.cri.planning.app.Version();
		}
		return _appCktlVersion;
	}

	// activation du service de collecte automatique
	public boolean appShouldSendCollecte() {
		return true;
	}

	private final static String KEY_TTL_PLANNING_READ = "TTL_PLANNING_READ";
	private final static String KEY_TTL_ICALENDAR_READ = "TTL_ICALENDAR_READ";
	private final static String KEY_TTL_ICALENDAR_WRITE = "TTL_ICALENDAR_WRITE";
	private final static String KEY_MAX_REMOTE_APP_RESPONSE_TIME = "MAX_REMOTE_APP_RESPONSE_TIME";
	private final static String KEY_ICALENDAR_WEEKS_BEFORE = "ICALENDAR_WEEKS_BEFORE";
	private final static String KEY_ICALENDAR_WEEKS_AFTER = "ICALENDAR_WEEKS_AFTER";
	private final static String KEY_HEARTBEAT_SEND_DELAY = "HEARTBEAT_SEND_DELAY";
	private final static String KEY_UNIV_ID = LocalSPConstantes.KEY_UNIV_ID;
	private final static String KEY_LRLOG = LocalSPConstantes.KEY_CKTLLOG;
	private final static String KEY_APP_ID = "APP_ID";
	private final static String KEY_APP_ALIAS = "APP_ALIAS";
	private final static String KEY_APP_ADMIN_PASSWORD = "APP_ADMIN_PASSWORD";

	private final static String[] LIST_MANDATORY_KEYS = new String[] {
			KEY_TTL_PLANNING_READ, KEY_TTL_ICALENDAR_READ, KEY_TTL_ICALENDAR_WRITE,
			KEY_MAX_REMOTE_APP_RESPONSE_TIME, KEY_ICALENDAR_WEEKS_BEFORE, KEY_ICALENDAR_WEEKS_AFTER,
			KEY_HEARTBEAT_SEND_DELAY, KEY_UNIV_ID, KEY_LRLOG,
			KEY_APP_ID, KEY_APP_ALIAS, KEY_APP_ADMIN_PASSWORD };

	/**
	 * La liste des parametres obligatoires dans le fichier de config / la table
	 * GRHUM.GRHUM.PARAMETRE
	 */
	public String[] configMandatoryKeys() {
		return LIST_MANDATORY_KEYS;
	}

	private final static String KEY_MAIN_LOGO_URL = "MAIN_LOGO_URL";
	private final static String KEY_SAUT_URL = "SAUT_URL";
	private final static String KEY_SAUT_ID_TRANSLATION = "SAUT_ID_TRANSLATION";
	private final static String KEY_HTML_CSS_STYLES = "HTML_CSS_STYLES";
	private final static String KEY_HTML_IMAGES_ROOT = "HTML_IMAGES_ROOT";
	private final static String KEY_HTML_JSCRIPT_ROOT = "HTML_JSCRIPT_ROOT";
	private final static String KEY_HTML_URL_LOGOS = "HTML_URL_LOGOS";
	private final static String KEY_ICS_SUFFIX_PATTERN = "ICS_SUFFIX_PATTERN";

	private final static String[] LIST_OPTIONAL_KEYS = new String[] {
			KEY_MAIN_LOGO_URL, KEY_SAUT_URL, KEY_SAUT_ID_TRANSLATION,
			KEY_HTML_CSS_STYLES, KEY_HTML_IMAGES_ROOT, KEY_HTML_JSCRIPT_ROOT,
			KEY_HTML_URL_LOGOS, KEY_ICS_SUFFIX_PATTERN };

	/**
	 * La liste des parametres optionnels dans le fichier de config / la table
	 * GRHUM.GRHUM.PARAMETRE
	 */
	public String[] configOptionalKeys() {
		return LIST_OPTIONAL_KEYS;
	}
}